From 79d633bb2c217ccbc4ee917c675288b57fa37bf8 Mon Sep 17 00:00:00 2001
From: Chris Sides <Christopher.Sides@hpe.com>
Date: Mon, 14 Jul 2025 18:42:34 -0500
Subject: [PATCH] added tachless-specific handling for how to display
 (estimated) 'fan_tach' info

Upstream-Status: Pending
---
 src/fan/FanMain.cpp    | 13 +++++++++++--
 src/fan/TachSensor.cpp | 15 +++++++++++++--
 src/fan/TachSensor.hpp |  2 ++
 3 files changed, 26 insertions(+), 4 deletions(-)

diff --git a/src/fan/FanMain.cpp b/src/fan/FanMain.cpp
index 4cd5a61..df3a1df 100644
--- a/src/fan/FanMain.cpp
+++ b/src/fan/FanMain.cpp
@@ -739,15 +739,24 @@ void createSensors(
 
             enableFanInput(fanOutputPath);
 
+            bool isTachlessFan= false;
             auto fanInputPath = getFanInputPath(fanOutputPath);
 
+            if (fanInputPath == fanOutputPath)
+            {
+                // no tachometer, so we are tachless fan
+                isTachlessFan = true;
+            }
+
+            
+
             auto& tachSensor = tachSensors[sensorName];
             tachSensor = nullptr;
             tachSensor = std::make_shared<TachSensor>(
                 fanInputPath.string(), baseType, objectServer, dbusConnection,
                 presenceGpio, monitorGpio, redundancy, io, sensorName,
-                std::move(sensorThresholds), *interfacePath, limits, powerState,
-                led);
+                std::move(sensorThresholds), *interfacePath, limits, isTachlessFan, 
+                powerState, led);
             tachSensor->setupRead();
 
             if (!pwmPath.empty() && std::filesystem::exists(pwmPath) &&
diff --git a/src/fan/TachSensor.cpp b/src/fan/TachSensor.cpp
index 258d9e7..8f65a96 100644
--- a/src/fan/TachSensor.cpp
+++ b/src/fan/TachSensor.cpp
@@ -53,13 +53,16 @@ TachSensor::TachSensor(
     const std::string& fanName,
     std::vector<thresholds::Threshold>&& thresholdsIn,
     const std::string& sensorConfiguration,
-    const std::pair<double, double>& limits, const PowerState& powerState,
+    const std::pair<double, double>& limits, 
+    const bool& isTachless,
+    const PowerState& powerState,
     const std::optional<std::string>& ledIn) :
     Sensor(escapeName(fanName), std::move(thresholdsIn), sensorConfiguration,
            objectType, false, false, limits.second, limits.first, conn,
            powerState),
     objServer(objectServer), redundancy(redundancy), presence(presenceGpio),
     monitor(monitorGpio),
+    isTachlessFan(isTachless),
     inputDev(io, path, boost::asio::random_access_file::read_only),
     waitTimer(io), path(path), led(ledIn)
 {
@@ -213,7 +216,15 @@ void TachSensor::handleResponse(const boost::system::error_code& err,
             }
             else
             {
-                updateValue(nvalue);
+                if (isTachlessFan) //then we're reading a PWM duty cycle as input. Calculate a displayable RPM from any MaxReading defined for a fan
+                {
+                    auto calcFract = (double)nvalue / 255;
+                    auto dutyToRPMCalc = static_cast<int>(calcFract * this->maxValue);
+
+                    updateValue(dutyToRPMCalc);
+                }
+                else
+                    updateValue(nvalue);
             }
         }
         else
diff --git a/src/fan/TachSensor.hpp b/src/fan/TachSensor.hpp
index d5b8b66..095b159 100644
--- a/src/fan/TachSensor.hpp
+++ b/src/fan/TachSensor.hpp
@@ -74,6 +74,7 @@ class TachSensor :
                std::vector<thresholds::Threshold>&& thresholds,
                const std::string& sensorConfiguration,
                const std::pair<double, double>& limits,
+               const bool& isTachless,
                const PowerState& powerState,
                const std::optional<std::string>& led);
     ~TachSensor() override;
@@ -89,6 +90,7 @@ class TachSensor :
     std::shared_ptr<PresenceGpio> monitor;
     std::shared_ptr<sdbusplus::asio::dbus_interface> itemIface;
     std::shared_ptr<sdbusplus::asio::dbus_interface> itemAssoc;
+    bool isTachlessFan = false;
     boost::asio::random_access_file inputDev;
     boost::asio::steady_timer waitTimer;
     std::string path;
