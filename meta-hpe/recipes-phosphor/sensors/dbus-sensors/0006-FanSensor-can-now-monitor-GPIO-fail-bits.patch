From f4b0fdb5a333bb672d0b98c0344b48cec3038869 Mon Sep 17 00:00:00 2001
From: Chris Sides <Christopher.Sides@hpe.com>
Date: Mon, 21 Jul 2025 14:32:14 -0500
Subject: [PATCH] FanSensor can now monitor GPIO fail bits

Upstream-Status: Pending
---
 src/fan/FanMain.cpp    | 105 +++++++++++++++++++++++++++++++++++++++--
 src/fan/TachSensor.cpp |  34 ++++++++++++-
 src/fan/TachSensor.hpp |   2 +
 3 files changed, 137 insertions(+), 4 deletions(-)

diff --git a/src/fan/FanMain.cpp b/src/fan/FanMain.cpp
index 79f1441..7eb7d1d 100644
--- a/src/fan/FanMain.cpp
+++ b/src/fan/FanMain.cpp
@@ -298,6 +298,8 @@ void createSensors(
         pwmSensors,
     boost::container::flat_map<std::string, std::weak_ptr<PresenceGpio>>&
         presenceGpios,
+    boost::container::flat_map<std::string, std::weak_ptr<PresenceGpio>>&
+        statusMonitorGpios,
     std::shared_ptr<sdbusplus::asio::connection>& dbusConnection,
     const std::shared_ptr<boost::container::flat_set<std::string>>&
         sensorsChanged,
@@ -307,6 +309,7 @@ void createSensors(
         GetSensorConfiguration>(dbusConnection, [&io, &objectServer,
                                                  &tachSensors, &pwmSensors,
                                                  &presenceGpios,
+                                                 &statusMonitorGpios,
                                                  &dbusConnection,
                                                  sensorsChanged](
                                                     const ManagedObjectType&
@@ -549,6 +552,99 @@ void createSensors(
                     }
                 }
             }
+
+            auto statusMonitorConfig =
+                 sensorData->find(cfgIntf + std::string(".StatusMonitor"));  //monitor for failures
+
+            std::shared_ptr<PresenceGpio> statusMonitorGpio(nullptr);
+
+            // statusMonitor sensors are optional
+            if (statusMonitorConfig != sensorData->end())
+            {
+                auto findFailPolarity = statusMonitorConfig->second.find("Polarity");
+                auto findFailPinName = statusMonitorConfig->second.find("PinName");
+
+                if (findFailPinName == statusMonitorConfig->second.end() ||
+                    findFailPolarity == statusMonitorConfig->second.end())
+                {
+                    lg2::error("Malformed statusMonitor Configuration");
+                }
+                else
+                {
+                    bool inverted =
+                        std::get<std::string>(findFailPolarity->second) == "Low";
+                    const auto* pinName =
+                        std::get_if<std::string>(&findFailPinName->second);
+
+                    if (pinName != nullptr)
+                    {
+                        auto findstatusMonitorGpio = statusMonitorGpios.find(*pinName);
+                        if (findstatusMonitorGpio != statusMonitorGpios.end())
+                        {
+                            auto p = findstatusMonitorGpio->second.lock();
+                            if (p)
+                            {
+                                statusMonitorGpio = p;
+                            }
+                        }
+                        if (!statusMonitorGpio)
+                        {
+                            auto findstatusMonitorType =
+                                statusMonitorConfig->second.find("MonitorType");
+                            bool polling = false;
+                            if (findstatusMonitorType != statusMonitorConfig->second.end())
+                            {
+                                auto mType = std::get<std::string>(
+                                    findstatusMonitorType->second);
+                                if (mType == "Polling")
+                                {
+                                    polling = true;
+                                }
+                                else if (mType != "Event")
+                                {
+                                    lg2::error(
+                                        "Unsupported GPIO MonitorType of '{TYPE}' for '{NAME}', "
+                                        "supported types: Polling, Event default",
+                                        "TYPE", mType, "NAME", sensorName);
+                                }
+                            }
+                            try
+                            {
+                                if (polling)
+                                {
+                                    statusMonitorGpio =
+                                        std::make_shared<PollingPresenceGpio>(
+                                            "Fan", sensorName, *pinName,
+                                            inverted, io);
+                                }
+                                else
+                                {
+                                    statusMonitorGpio =
+                                        std::make_shared<EventPresenceGpio>(
+                                            "Fan", sensorName, *pinName,
+                                            inverted, io);
+                                }
+                                statusMonitorGpios[*pinName] = statusMonitorGpio;
+                            }
+                            catch (const std::system_error& e)
+                            {
+                                lg2::error(
+                                    "Failed to create GPIO monitor object for "
+                                    "'{PIN_NAME}' / '{SENSOR_NAME}': '{ERROR}'",
+                                    "PIN_NAME", *pinName, "SENSOR_NAME",
+                                    sensorName, "ERROR", e);
+                            }
+                        }
+                    }
+                    else
+                    {
+                        lg2::error(
+                            "Malformed statusMonitor pinName for sensor '{NAME}'",
+                            "NAME", sensorName);
+                    }
+                }
+            }
+
             std::optional<RedundancySensor>* redundancy = nullptr;
             redundancy = &systemRedundancy;
             
@@ -647,7 +743,7 @@ void createSensors(
             tachSensor = nullptr;
             tachSensor = std::make_shared<TachSensor>(
                 fanInputPath.string(), baseType, objectServer, dbusConnection,
-                presenceGpio, redundancy, io, sensorName,
+                presenceGpio, statusMonitorGpio, redundancy, io, sensorName,
                 std::move(sensorThresholds), *interfacePath, limits, powerState,
                 led);
             tachSensor->setupRead();
@@ -684,12 +780,14 @@ int main()
         pwmSensors;
     boost::container::flat_map<std::string, std::weak_ptr<PresenceGpio>>
         presenceGpios;
+    boost::container::flat_map<std::string, std::weak_ptr<PresenceGpio>>
+        statusMonitorGpios;
     auto sensorsChanged =
         std::make_shared<boost::container::flat_set<std::string>>();
 
     boost::asio::post(io, [&]() {
         createSensors(io, objectServer, tachSensors, pwmSensors, presenceGpios,
-                      systemBus, nullptr);
+                      statusMonitorGpios, systemBus, nullptr);
     });
 
     boost::asio::steady_timer filterTimer(io);
@@ -716,7 +814,8 @@ int main()
                     return;
                 }
                 createSensors(io, objectServer, tachSensors, pwmSensors,
-                              presenceGpios, systemBus, sensorsChanged, 5);
+                              presenceGpios, statusMonitorGpios, systemBus,
+                              sensorsChanged, 5);
             });
         };
 
diff --git a/src/fan/TachSensor.cpp b/src/fan/TachSensor.cpp
index c8a3c40..a3d9fae 100644
--- a/src/fan/TachSensor.cpp
+++ b/src/fan/TachSensor.cpp
@@ -48,6 +48,7 @@ TachSensor::TachSensor(
     sdbusplus::asio::object_server& objectServer,
     std::shared_ptr<sdbusplus::asio::connection>& conn,
     std::shared_ptr<PresenceGpio>& presenceGpio,
+    std::shared_ptr<PresenceGpio>& statusMonitorGpio,
     std::optional<RedundancySensor>* redundancy, boost::asio::io_context& io,
     const std::string& fanName,
     std::vector<thresholds::Threshold>&& thresholdsIn,
@@ -58,6 +59,7 @@ TachSensor::TachSensor(
            objectType, false, false, limits.second, limits.first, conn,
            powerState),
     objServer(objectServer), redundancy(redundancy), presence(presenceGpio),
+    statusMonitor(statusMonitorGpio),
     inputDev(io, path, boost::asio::random_access_file::read_only),
     waitTimer(io), path(path), led(ledIn)
 {
@@ -85,6 +87,7 @@ TachSensor::TachSensor(
         itemIface->register_property("PrettyName",
                                      std::string()); // unused property
         itemIface->register_property("Present", true);
+
         itemIface->initialize();
         itemAssoc = objectServer.add_interface(
             "/xyz/openbmc_project/inventory/" + name, association::interface);
@@ -95,6 +98,12 @@ TachSensor::TachSensor(
                  "/xyz/openbmc_project/sensors/fan_tach/" + name}});
         itemAssoc->initialize();
     }
+
+    if (statusMonitor)
+    {
+        statusMonitor->monitorPresence(); //kick off monitoring (polling) for the status/fail bit or handle
+    }
+
     setInitialProperties(sensor_paths::unitRPMs);
 }
 
@@ -156,6 +165,7 @@ void TachSensor::handleResponse(const boost::system::error_code& err,
         return; // we're being destroyed
     }
     bool missing = false;
+    bool failed = false;
     size_t pollTime = pwmPollMs;
     if (presence)
     {
@@ -168,6 +178,16 @@ void TachSensor::handleResponse(const boost::system::error_code& err,
         itemIface->set_property("Present", !missing);
     }
 
+    if (!missing && statusMonitor)
+    {
+        failed  = statusMonitor->isPresent();
+        if (failed)
+        {
+            markFunctional(false);
+            pollTime = sensorFailedPollTimeMs;
+        }
+    }
+
     if (!missing)
     {
         if (!err)
@@ -192,14 +212,26 @@ void TachSensor::handleResponse(const boost::system::error_code& err,
             pollTime = sensorFailedPollTimeMs;
         }
     }
-
+    
     restartRead(pollTime);
 }
 
 void TachSensor::checkThresholds()
 {
+
     bool status = thresholds::checkThresholds(this);
 
+    if (presence->isPresent() && statusMonitor)
+    {
+        bool failureDetected = statusMonitor->isPresent();
+
+        if (failureDetected)
+        {
+            status = false;
+            lg2::error("failbit seen for fan_tach '{NAME}', status=false", "NAME", name);
+        }
+    }
+
     if ((redundancy != nullptr) && *redundancy)
     {
         (*redundancy)
diff --git a/src/fan/TachSensor.hpp b/src/fan/TachSensor.hpp
index 6e22f76..dcd8e1f 100644
--- a/src/fan/TachSensor.hpp
+++ b/src/fan/TachSensor.hpp
@@ -68,6 +68,7 @@ class TachSensor :
                sdbusplus::asio::object_server& objectServer,
                std::shared_ptr<sdbusplus::asio::connection>& conn,
                std::shared_ptr<PresenceGpio>& presence,
+               std::shared_ptr<PresenceGpio>& statusMonitor,
                std::optional<RedundancySensor>* redundancy,
                boost::asio::io_context& io, const std::string& fanName,
                std::vector<thresholds::Threshold>&& thresholds,
@@ -85,6 +86,7 @@ class TachSensor :
     sdbusplus::asio::object_server& objServer;
     std::optional<RedundancySensor>* redundancy;
     std::shared_ptr<PresenceGpio> presence;
+    std::shared_ptr<PresenceGpio> statusMonitor;
     std::shared_ptr<sdbusplus::asio::dbus_interface> itemIface;
     std::shared_ptr<sdbusplus::asio::dbus_interface> itemAssoc;
     boost::asio::random_access_file inputDev;
